<?php
/**
 * Created by PhpStorm.
 * User: zwg2
 * Date: 11/10/14
 * Time: 1:34 PM
 *
 *
 * Accesses data in the two CSV files (determined by whether the given date is a weekday or weekend)
 * to assign a flightId to each flight on each day for users to be able to search flights
 */


//set start date for schedule
private $startDate = "2014-11-15 00:00:00";

//create date object from start date with standard mySQL format
private $formatDateTime = "Y-m-d H:i:s";
private $date = DateTimeImmutable::createFromFormat($formatDateTime, $startDate);

//set initial seats available on each plane to 20
private $initialTotalSeatsOnPlane = 20;

//open the "weekDayCsv.csv" to have ready for use during loops
if(($weekDayPointer = fopen("weekDayCsv.csv", "r")) === false){
	throw(new RuntimeException("Unable to Open 'weekDay CSV export-Table 1.csv'"));
}


//open the "weekEndCsv.csv" to have ready for use during loops
if(($weekEndPointer = fopen("weekEndCsv.csv", "r")) === false){
	throw(new RuntimeException("Unable to Open 'weekEnd CSV export-Table 1.csv'"));
}


//fixme: add full doc-bloc with parameters etc.
/**
 * increment by 1 day, run through schedule files in a loop, build flights from seed data CSVs
 * @param resource $mysqli pointer to mySQL connection, by reference
 * @param $weekDayPointer
 * @param $weekEndPointer
 * @param $date
 * @param $initialTotalSeatsOnPlane
 * @throws mysqli_sql_exception when mySQL related errors occur
 **/
function	buildFlights (&$mysqli, $weekDayPointer, $weekEndPointer, $date, $initialTotalSeatsOnPlane) {

	//first, create query template
	$query = "INSERT INTO flight (origin, destination, duration, departureDateTime, arrivalDateTime, flightNumber, price, totalSeatsOnPlane)
				VALUES(?, ?, ?, ?, ?, ?, ?,?)";
	$statement = $mysqli->prepare($query);
	if($statement === false) {
		throw(new mysqli_sql_exception("Unable to prepare statement"));
	}

	//run loop for 2 years worth of data, checking which schedule to pull from on each day
	for($i = 0; $i < 730; $i++) { //counter number is wrong 845

		//fixme use DateTime to reformat this as an  //won't this mean i have to recreate the object as a string?  ie less elegant?  why do this way?
		//get day of week for the date in the current loop
		$dayOfWeek = date("N",$date->getTimestamp());

		//"if date is weekday, then do following:"
		if($dayOfWeek < 6) {


			//go through each row of the relevant schedule and build all flights for this date
			while(($output = fgetcsv($weekDayPointer, 0, ",")) !== false) {

				//$output[0, 1, 5, 9, 13] come in as strings and will be used as such for origin/destination/flight numbers

				//$output[2-4] and [7-8] and [11-12] come in as a string but have to be an interval of hours to be used in calcs
				//except for $output[2], all of these also have to be added to the date of current loop to create a DATETIME

				//first, explode the string into an array to be able to turn it into a DateInterval object.  Start with the
				//defualt case of the first flight which is always populated.  Then do same for Flight 2 and 3 when they exist.


				/*

				$explode2 = explode(":", $output[2]);
				$explode3 = explode(":", $output[3]);
				$explode4 = explode(":", $output[4]);


				//second, use the exploded strings to create the DateInteval.  Duration will remain a DateInterval.
				$duration = DateInterval::createFromDateString("$explode2[0] hour + $explode2[1] minutes");
				$departureTime1 = DateInterval::createFromDateString("$explode3[0] hour + $explode3[1] minutes");
				$arrivalTime1 = DateInterval::createFromDateString("$explode4[0] hour + $explode4[1] minutes");

				//third, add the relevant intervals to the current date in the loop to make a DATETIME object for each flight
				$dateTimeDep1 = $date->add($departureTime1);
				$dateTimeArr1 = $date->add($arrivalTime1);

				//FIXME: price formatting
				//fourth, $output[6,10,14] come in as a float and need precision set to two decimal places for eventual conversion to dollar format
				//		$basePriceFlight1 = (int) $output[6];
				//		$basePriceFlight2 = (int) $output[10];
				//		$basePriceFlight3 = (int) $output[14];

				// First, explode the duration string into an array to be able to turn it into a DateInterval object to be used in calcs
				$explode2 = explode(":", $output[2]);

				//second, use the exploded string to create the DateInteval.  Duration will remain a DateInterval.
				$duration = DateInterval::createFromDateString("$explode2[0] hour + $explode2[1] minutes");

				*/


				// set index base counter for do while loop to 3 for first flight arrival field
				$a = 3;

				do 	{
					//set second counter for ease
					$b = $a+1;

					//CSV $output[0, 1, 5, 9, 13] come in as strings and will be used as such for origin/destination/flight numbers

					//$output[2-4] and [7-8] and [11-12] come in as a string but have to be an interval of hours to be used in calcs
					//except for $output[2], all of these also have to be added to the date of current outer loop to create a DATETIME,
					//then re-formated once again as a string to be re-inserted to mySQL

					// First, explode the string into an array to be able to turn it into a DateInterval object.
					// Start with the defualt case of the first flight which is always populated.  Then do same for Flight 2 and 3 when they exist.

						//fixme to be more elegant
					$explodeA = explode(":", $output[$a]);
					$explodeB = explode(":", $output[$b]);


					//second, use the exploded strings to create the DateInteval.
					$departureTime = DateInterval::createFromDateString("$explodeA[0] hour + $explodeA[1] minutes");
					$arrivalTime = DateInterval::createFromDateString("$explodeB[0] hour + $explodeB[1] minutes");

					//third, add the relevant intervals to the current date in the loop to make a DATETIME object for each flight
					$dateTimeDep = $date->add($departureTime);
					$dateTimeArr = $date->add($arrivalTime);

					//convert all DateTime and DateInteval Objects to strings for re-insertion //fixme: don't we need them in DateInterval format for future math calculations?


					//array to hold all results//fixme: how do we build to an array before inserting

					$wasClean = $statement->bind_param("ssssssdi", $output[0], $output[1], $output[2], $dateTimeDep,
						$dateTimeArr, $output[$a+2], $output[$a+3], $initialTotalSeatsOnPlane);


					if($wasClean === false) {
						throw(new mysqli_sql_exception("Unable to bind parameters"));
					}
					if($statement->execute() === false) {
						throw(new mysqli_sql_exception("Unable to execute mySQL statement"));
					}

					//increment counter to index of the next flight departure
					$a = $a + 4;

				} while (empty($output[$a]) !== false || $output[$a] !== false ); //FIXME: ask whether need both



				/*

					//fixme: above changes compared to below include: do all the ifs as a do while loop; change datetime objects to a string to insert
					//check for flight 2 on seed row and insert if exists:
						if(empty($output[7]) === false) {
							//repeat steps from default case for Flight 2
							$explode7 = explode(":", $output[7]);
							$explode8 = explode(":", $output[8]);
							$departureTime2 = DateInterval::createFromDateString("$explode7[0] hour + $explode7[1] minutes");
							$arrivalTime2 = DateInterval::createFromDateString("$explode8[0] hour + $explode8[1] minutes");
							$dateTimeDep2 = $date->add($departureTime2);
							$dateTimeArr2 = $date->add($arrivalTime2);

							$wasClean = $statement->bind_param("ssssssdi", $output[0], $output[1], $duration, $dateTimeDep2,
								$dateTimeArr2, $output[9], $output[10], $initialTotalSeatsOnPlane);

							if($wasClean === false) {
								throw(new mysqli_sql_exception("Unable to bind parameters"));
							}
							if($statement->execute() === false) {
								throw(new mysqli_sql_exception("Unable to execute mySQL statement"));
							}


							//check for flight 3 on seed row and insert if it exists:
							if(empty($output[11]) === false) {
								//repeat steps from default case for Flight 3
								$explode11 = explode(":", $output[11]);
								$explode12 = explode(":", $output[12]);
								$departureTime3 = DateInterval::createFromDateString("$explode11[0] hour + $explode11[1] minutes");
								$arrivalTime3 = DateInterval::createFromDateString("$explode12[0] hour + $explode12[1] minutes");
								$dateTimeDep3 = $date->add($departureTime3);
								$dateTimeArr3 = $date->add($arrivalTime3);

								$wasClean = $statement->bind_param("ssssssdi", $output[0], $output[1], $duration, $dateTimeDep3,
																				$dateTimeArr3, $output[13], $output[14], $initialTotalSeatsOnPlane);
								if($wasClean === false) {
									throw(new mysqli_sql_exception("Unable to bind parameters"));
								}
								if($statement->execute() === false) {
									throw(new mysqli_sql_exception("Unable to execute mySQL statement"));
								}

							}
						}
				*/
			}

			//repeat of code above with $weekEndPointer
		} else if($dayOfWeek === 6 || $dayOfWeek === 7) {
			//fixme: repeat code above, change file name to $weekEndPointer

		} else {
			throw(new Exception("DayOfWeek returned an unmatched value"));
		}

		//add 1 day to immutable $date object
		$loopByDay = DateInterval::createFromDateString("1 day");
		$date=$date->add ($loopByDay);

	}

	fclose($weekDayPointer);
	fclose($weekEndPointer);
}

//end function
//
//
//
//
//
//
//
//
//
//
//

/*//
//$num = count($output);


	//$date->add(new DateInterval('P1D'));

	// create second query template to insert
	$query2 = "INSERT INTO flight (flightId, origin, destination, duration, departureTime, arrivalTime,
																flightNumber, price, totalSeatsOnPlane) VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?)";
	$statement2 = $mysqli->prepare($query2);
	if($statement2 === false) {
		throw(new mysqli_sql_exception("Unable to prepare statement"));
	}

	// bind the member variables to the place holders in the template
	$wasClean2 = $statement2->bind_param("issssssii", $flightId, $row["origin"], $row["destination"], $row["duration"],
		$row["departureTime"], $row["arrivalDateTime"], $row["flightNumber"],
		$row["price"], $totalSeatsOnPlane);

	if($wasClean2 === false) {
		throw(new mysqli_sql_exception("Unable to bind parameters"));
	}

	// execute the statement
	if($statement2->execute() === false) {
		throw(new mysqli_sql_exception("Unable to execute mySQL statement"));
	}



	// create second query template to insert
				$query2 = "INSERT INTO flight (flightId, origin, destination, duration, departureTime, arrivalTime,
																flightNumber, price, totalSeatsOnPlane) VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?)";
				$statement2 = $mysqli->prepare($query2);
				if($statement2 === false) {
					throw(new mysqli_sql_exception("Unable to prepare statement"));
				}

				// bind the member variables to the place holders in the template
				$wasClean2 = $statement2->bind_param("issssssii", $flightId, $row["origin"], $row["destination"], $row["duration"],
					$row["departureTime"], $row["arrivalDateTime"], $row["flightNumber"],
					$row["price"], $totalSeatsOnPlane);

				if($wasClean2 === false) {
					throw(new mysqli_sql_exception("Unable to bind parameters"));
				}

				// execute the statement
				if($statement2->execute() === false) {
					throw(new mysqli_sql_exception("Unable to execute mySQL statement"));
				}










	// convert the associative array to a Flight
			if($row !== null) {
				try {
					$flight = new Flight ($flightId, $row["origin"], $row["destination"], $row["duration"], $row["departureTime"],
						$row["arrivalDateTime"], $row["flightNumber"],$row["price"], $totalSeatsOnPlane);
				} catch(Exception $exception) {
					// if the row couldn't be converted, rethrow it
					throw(new mysqli_sql_exception("Unable to convert row to Flight", 0, $exception));
				}

				// if we got here, the Flight is good - return it
				return ($flight);
			} else {
				// 404 User not found - return null instead
				return (null);
			}
		}


			insert flightId, $date, everything on row $i of tableWeekDaySchedule;

				$flightId++;

			}
	}
	else for ($i=0,$i< count(tableWeekEndSchedule), $i++) {

		insert flightId, $date, everything on row $i of tableWeekEndSchedule;

				$flightId++;
		}

	$date++;

}


	//CREATE QUERY TEMPLATE
	$query = "SELECT origin, destination, duration, departureTime, arrivalTime, flightNum, price
					FROM weekdaySchedule WHERE weekdayScheduleId = ? ";
	$statement = $mysqli->prepare($query);
	if($statement === false) {
		throw(new mysqli_sql_exception("Unable to prepare statement"));
	}
	$i = 0;
	do {


		//bind the profileId to the place holder in the template
		$wasClean = $statement->bind_param("i", $i);
		if($wasClean === false) {
			throw(new mysqli_sql_exception("Unable to bind parameters"));
		}

		//execute statement
		if($statement->execute() === false) {
			throw(new mysqli_sql_exception("Unable to execute mySQL statement"));
		}

		//get result from the SELECT query
		$result = $statement->get_result();
		if($result === false) {
			throw(new mysqli_sql_exception("Unable to get result set"));
		}

		$row = $result->fetch_assoc();

		if(empty($row) === false) {
			INSERT INTO flight(flightId, origin, destination, etc) VALUES(?, ? , ?)

			bind_params("iss", null, $row['origin'], $row['destination'], $row['duration'] ['departureTime']);
		}
		$i++;
	} while ($row !== null);



















	$format = "Y-m-d";
	$date = DateTime::createFromFormat($format, $startDate);

	for($i=0; $i<730; $i++) {


	}




























		ini_set('date.timezone', 'Europe/Lisbon');

		$cal = new IntlGregorianCalendar(NULL, 'en_US');
		$cal->set(2013, 6, 7); // a Sunday

		var_dump($cal->isWeekend()); // true

		$date = 2014-12-01;//php has a function which will tell you the day of week
		if ($date = weekday) {

			for($i = 0, $i < count(tableWeekDaySchedule), $i++) {

				insert flightId, $date, everything on row $i of tableWeekDaySchedule;

				$flightId++;

			}
		}
		else for ($i=0,$i< count(tableWeekEndSchedule), $i++) {

				insert flightId, $date, everything on row $i of tableWeekEndSchedule;

				$flightId++;
		}

		$date++;

	}





}



*/






?>





//pseudo code for testFlight



/*


// NESTED LOOPS:
	// LOOP 1: for number of origins, assign each in the array to $userOrigin variable	}
}

/*
	Loop 2: same for destinations
		but i think a do/while to skip first origin/origin overlap, then....
		after that, if  next.destination in loop is same as this.origin, skip destination
		(i.e. add two instead of 1 to array index counter)

	Loop 3: USER_NUMBER_PASSENGERS = 15, <30, +10 (verifies null results if
		call static user search method to get result in form of 3D array
		if USER_NUMBER_PASSENGERS < totalSeatsOnPlane of 20, verify results not null or throw exception
		else verify results ARE null for over 20 passengers and return;

	Loop 4: for loop to iterate through dimension 1 result array "allPaths[]"
		for (i=0, allPaths[i] !== null, i++) {
			count size of 2nd dimension array allPaths[i]
			assert allPaths[i][0]["origin"] =  this.origin of loop 1
			assert allPaths[i][size of allPaths[i]]["destination"] = this.destination of loop 2
			assert allPaths[i][size of allPaths[i]]["arrivalDateTime"] - allPaths[i][0]["departureDateTime"] <= range variable
		}

	Loop 5A: for loop to compare arrival/departure times in results and verify no overlaps
		for (a=0, allPaths[i][a+1] !== null, a++) {
			allPaths[i][a+1]["departureDateTime"] - allPaths[i][a]["arrivalDateTime] >= minLayover;
		}
	Loop 5B (sibling not child of 5A): Assert identical each flightId's info with a select from the database
		for (a=0, allPaths[i][a] !== null, a++) {
			SELECT FROM flight (all fields) WHERE flightId = allPaths[i][a];
			row = result-> fetch_assoc();

			for (b=0, allPaths[i][a][b] !== null, b++) {
				Assert allPaths[i][a][b] identical to row[b]

//fixme: need it to be 3D array instead of 2D array of objects to check each field?
for($g=0; $thisArrayOfPaths[$d][$f][$g] !== null; $g++) {


/*
// create query template for SELECT
$querySelect = "SELECT * FROM flight WHERE flightId = ?";
$statement = $mysqli->prepare($querySelect);
if($statement === false) {
throw(new mysqli_sql_exception("Unable to prepare statement"));
}

// bind the flightId to the place holder in the template
$wasClean = $statement->bind_param("i", );
if($wasClean === false) {
throw(new mysqli_sql_exception("Unable to bind parameters"));
}

// execute the statement
if($statement->execute() === false) {
throw(new mysqli_sql_exception("Unable to execute mySQL statement"));
}

// get result from the SELECT query *pounds fists*
$result = $statement->get_result();
if($result === false) {
throw(new mysqli_sql_exception("Unable to get result set"));
}

// since this field is unique to this flightId, this will only return 0 or 1 results. So...
// 1) if there's a result, we can use it to calc
// 2) if there's no result, we can just return null
$row = $result->fetch_assoc(); // fetch_assoc() returns a row as an associative array
*/


}
		}

	//repeat whole thing for a different day, like a weekend instead of weekday

	/

	// declare necessary variables to send to function for weekday
	$USER_ORIGIN = $ORIGIN;
	$USER_DESTINATION = $DESTINATION;
	$USER_FLY_DATE_START = "2014-12-04 00:00:00";
	$USER_FLY_DATE_END = "2014-12-05 00:00:00";

	do {

		$USER_NUMBER_PASSENGERS = 1;

		//fixme concrete mysqli?
		// call the user search function and var dump the results for visual verification
		$staticPaths = Flight::getRoutesByUserInput($this->mysqli, $USER_ORIGIN, $USER_DESTINATION, $USER_FLY_DATE_START,
			$USER_FLY_DATE_END, $USER_NUMBER_PASSENGERS);
		//var_dump($staticPaths);

		$USER_NUMBER_PASSENGERS = $USER_NUMBER_PASSENGERS + 5;


	} while ($USER_NUMBER_PASSENGERS < 30);



	// declare necessary new variables to send to function for weekend return flight
	$USER_RETURN_DATE_START = "2014-12-07 00:00:00";
	$USER_RETURN_DATE_END = "2014-12-08 00:00:00";

	do {

		$USER_NUMBER_PASSENGERS2 = 1;

		//fixme concrete mysqli?
		// call the user search function with reversed origin/destination and var dump the results for visual verification
		$staticPaths = Flight::getRoutesByUserInput($this->mysqli, $USER_DESTINATION, $USER_ORIGIN, $USER_RETURN_DATE_START,
																	$USER_RETURN_DATE_END, $USER_NUMBER_PASSENGERS2);
		//var_dump($staticPaths);

		$USER_NUMBER_PASSENGERS2 = $USER_NUMBER_PASSENGERS2 + 5;


	} while ($USER_NUMBER_PASSENGERS2 < 30);

}
*/



// discarded code for flight user search:

/* old code: fixme delete eventually
				// bind the user inputs to the place holder in the template to make a 2 dimensional array (array of arrays
				// of all related info for each flight ID in a path)
				$wasClean = $statement2->bind_param("s", $row["path"]);

				if($wasClean === false) {
					throw(new mysqli_sql_exception("Unable to bind parameters"));
				}

				// execute the statement
				if($statement2->execute() === false) {
					echo "<p>line 1000 of flight, dump of statement2 error for eachflightpathobject before throwing error</p>";
					var_dump($statement2->error);
					throw(new mysqli_sql_exception("Unable to execute mySQL statement"));
				}

				echo "<p>line 1004 of flight dump of statement2 before getting eachflightpathobject result</p>";
				var_dump($statement2);


				// get result from the SELECT query *pounds fists*
				// this represents the two dimensional array (flight ids with all their associated data)
				$eachFlightPathObject = $statement2->get_result();
				if($eachFlightPathObject === false) {
					throw(new mysqli_sql_exception("Unable to get result set"));
				}

				echo "<p>line 1016 of flight dump of eachFlightPathObject</p>";
				var_dump($eachFlightPathObject);


				// fixme: isn't this just a result object tho?  Have to convert it to an array of arrays? think we need to fetch assoc again for this new result object, but how are multidimensional associative arrays indexed in this case... use array of objects
				// fixme: so if we have an array of flight objects, instead of an array of flightIDs, each of which is an array of info with that flight, we can still access those flight specific variables we need to do necessary math and add to the array?  How do we reference those variables within each flight object?
				// fixme: So final array would be array of objects + 2 variables of duration and price.
				$eachFlightPath = $eachFlightPathObject->fetch_assoc();
				echo "<p>line 1024 of flight dump of eachFlightPath after fetchassoc for eachflightpathobject</p>";
				var_dump($eachFlightPathObject);
*/


/* old code: fixme delete eventually

		// this will return as many results as there are flights and flight combos with same origin + departure + date.
		//	1) if there's no result, we can just return null
		// 2) if there's a result, we can make it into flight objects by using the flight path string
		// fetch_assoc() returns row as associative arr until row is null

		// create query to take results from stored procedure and get all related info for each flight returned
		$query = "SELECT flightId, origin, destination, duration, departureDateTime, arrivalDateTime, flightNumber, price,
 					totalSeatsOnPlane FROM flight WHERE flightId IN (?)";

		$statement2 = $mysqli->prepare($query);
		if($statement2 === false) {
			throw(new mysqli_sql_exception("Unable to prepare statement"));
		}
*/